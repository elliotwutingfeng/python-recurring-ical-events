"""This tests the range parameter for ics file.
see https://github.com/niccokunzmann/python-recurring-ical-events/issues/75
Description:  This parameter can be specified on a property that
    specifies a recurrence identifier.  The parameter specifies the
    effective range of recurrence instances that is specified by the
    property.  The effective range is from the recurrence identifier
    specified by the property.  If this parameter is not specified on
    an allowed property, then the default range is the single instance
    specified by the recurrence identifier value of the property.  The
    parameter value can only be "THISANDFUTURE" to indicate a range
    defined by the recurrence identifier and all subsequent instances.
    The value "THISANDPRIOR" is deprecated by this revision of
    iCalendar and MUST NOT be generated by applications.
"""

import pytest
from datetime import time


@pytest.mark.parametrize(
    ("date", "summary"),
    [
        ("20240901", "ORIGINAL EVENT"),
        ("20240911", "ORIGINAL EVENT"),
        ("20240913", "MODIFIED EVENT"),
        ("20240915", "MODIFIED EVENT"),  # Normal recurrence-id
        ("20240917", "MODIFIED EVENT"),
        ("20240919", "MODIFIED EVENT"),
        ("20240921", "MODIFIED EVENT"),
        ("20240922", "EDITED EVENT"),
        ("20240924", "EDITED EVENT"),  # RDATE
        ("20240925", "EDITED EVENT"),
    ],
)
def test_issue_75_RANGE_AT_parameter(calendars, date, summary):
    events = calendars.issue_75_range_parameter.at(date)
    assert len(events) == 1, f"Expecting one event at {date}"
    event = events[0]
    assert str(event["SUMMARY"]) == summary


@pytest.mark.parametrize(
    ("start", "end", "summary", "total"),
    [
        ("20240901T000000Z", "20240911T235959Z", "ORIGINAL EVENT", 6),
        ("20240901T000000Z", "20240913T000000Z", "ORIGINAL EVENT", 6),
        ("20240901T000000Z", "20240913T235959Z", "MODIFIED EVENT", 7),
        (
            "20240901T000000Z",
            "20240915T235959Z",
            "MODIFIED EVENT",
            8,
        ),  # Normal recurrence-id
        ("20240901T000000Z", "20240917T235959Z", "MODIFIED EVENT", 9),
        ("20240901T000000Z", "20240919T235959Z", "MODIFIED EVENT", 10),
        ("20240901T000000Z", "20240921T235959Z", "MODIFIED EVENT", 11),
        ("20240901T000000Z", "20240922T000000Z", "MODIFIED EVENT", 11),
        ("20240901T000000Z", "20240922T235959Z", "EDITED EVENT", 12),
        ("20240901T000000Z", "20240923T000000Z", "EDITED EVENT", 12),
        ("20240901T000000Z", "20240923T235959Z", "EDITED EVENT", 13),
        ("20240901T000000Z", "20240924T235959Z", "EDITED EVENT", 14),  # RDATE
        ("20240901T000000Z", "20240925T235959Z", "EDITED EVENT", 15),
        (
            "20240913T000000Z",
            "20240922T000000Z",
            "MODIFIED EVENT",
            5,
        ),  # out of query bounds
        (
            "20240913T000000Z",
            "20240922T235959Z",
            "EDITED EVENT",
            6,
        ),  # out of query bounds
        (
            "20240924T000000Z",
            "20240925T235959Z",
            "EDITED EVENT",
            2,
        ),  # out of query bounds
    ],
)
def test_issue_75_RANGE_BETWEEN_parameter(calendars, start, end, summary, total):
    events = calendars.issue_75_range_parameter.between(start, end)
    assert (
        len(events) == total
    ), f"Expecting {total} events at range {start}, {end}, get {len(events)}"
    event = events[-1]
    assert str(event["SUMMARY"]) == summary


@pytest.mark.parametrize(
    ("date", "start", "end"),
    [
        ((2024, 9, 13, 9), (9, 0), (16, 0)),  # The modification itself
        ((2024, 9, 15, 9), (9, 0), (16, 0)),  # The recurrence after this moved
        ((2024, 9, 22, 14, 22), (14, 22), (16, 13)),  # The modification itself
        ((2024, 9, 24, 14, 22), (14, 22), (16, 13)),  # The modification itself
    ]
)
def test_the_length_of_modified_events(calendars, date, start, end):
    """There should be one event exactly starting and ending at these times."""
    events = calendars.issue_75_range_parameter.at(date)
    assert len(events) != 0, "The calculation could not find an event!"
    assert len(events) == 1, "Modify the test to yield one event only!"
    event = events[0]
    assert event["DTSTART"].dt.time() == time(*start)
    assert event["DTEND"].dt.time() == time(*end)
